
spiel.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000720  00000000  00000000  00000094  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000aa  00800060  00000720  000007b4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000018  0080010a  0080010a  0000085e  2**0
                  ALLOC
  3 .noinit       00000000  00800122  00800122  0000085e  2**0
                  CONTENTS
  4 .eeprom       00000000  00810000  00810000  0000085e  2**0
                  CONTENTS
  5 .stab         00001efc  00000000  00000000  00000860  2**2
                  CONTENTS, READONLY, DEBUGGING
  6 .stabstr      00000ecc  00000000  00000000  0000275c  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54
   4:	0c 94 45 00 	jmp	0x8a
   8:	0c 94 45 00 	jmp	0x8a
   c:	0c 94 45 00 	jmp	0x8a
  10:	0c 94 45 00 	jmp	0x8a
  14:	0c 94 45 00 	jmp	0x8a
  18:	0c 94 45 00 	jmp	0x8a
  1c:	0c 94 45 00 	jmp	0x8a
  20:	0c 94 45 00 	jmp	0x8a
  24:	0c 94 45 00 	jmp	0x8a
  28:	0c 94 47 00 	jmp	0x8e
  2c:	0c 94 45 00 	jmp	0x8a
  30:	0c 94 45 00 	jmp	0x8a
  34:	0c 94 45 00 	jmp	0x8a
  38:	0c 94 45 00 	jmp	0x8a
  3c:	0c 94 45 00 	jmp	0x8a
  40:	0c 94 45 00 	jmp	0x8a
  44:	0c 94 45 00 	jmp	0x8a
  48:	0c 94 45 00 	jmp	0x8a
  4c:	0c 94 45 00 	jmp	0x8a
  50:	0c 94 45 00 	jmp	0x8a

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d8 e0       	ldi	r29, 0x08	; 8
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	11 e0       	ldi	r17, 0x01	; 1
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	e0 e2       	ldi	r30, 0x20	; 32
  68:	f7 e0       	ldi	r31, 0x07	; 7
  6a:	02 c0       	rjmp	.+4      	; 0x70

0000006c <.do_copy_data_loop>:
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
  70:	aa 30       	cpi	r26, 0x0A	; 10
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c

00000076 <__do_clear_bss>:
  76:	11 e0       	ldi	r17, 0x01	; 1
  78:	aa e0       	ldi	r26, 0x0A	; 10
  7a:	b1 e0       	ldi	r27, 0x01	; 1
  7c:	01 c0       	rjmp	.+2      	; 0x80

0000007e <.do_clear_bss_loop>:
  7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
  80:	a2 32       	cpi	r26, 0x22	; 34
  82:	b1 07       	cpc	r27, r17
  84:	e1 f7       	brne	.-8      	; 0x7e
  86:	0c 94 59 01 	jmp	0x2b2

0000008a <__bad_interrupt>:
  8a:	0c 94 00 00 	jmp	0x0

0000008e <__vector_10>:

unsigned char STEP_FUZZ1;

SIGNAL(SIG_OUTPUT_COMPARE0)
{
  8e:	1f 92       	push	r1
  90:	0f 92       	push	r0
  92:	0f b6       	in	r0, 0x3f	; 63
  94:	0f 92       	push	r0
  96:	11 24       	eor	r1, r1
  98:	2f 93       	push	r18
  9a:	3f 93       	push	r19
  9c:	4f 93       	push	r20
  9e:	8f 93       	push	r24
  a0:	9f 93       	push	r25
  a2:	ef 93       	push	r30
  a4:	ff 93       	push	r31
	static unsigned char timer1, timer2, timer3;		//these control the step frequency

	static unsigned char step1, step2, step3;		//state of the stepper motors
	static unsigned char ls1, ls2, ls3;
	static unsigned char bmode1, bmode2, bmode3;
	
	static unsigned char btable[]={0,60,47,41,37,34,31,28,26,24,23,21,20,19,18,17,16,15,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14};
	
	char reload1;
		
	
	if(RUN1){
  a6:	80 91 1a 01 	lds	r24, 0x011A
  aa:	88 23       	and	r24, r24
  ac:	09 f4       	brne	.+2      	; 0xb0
  ae:	62 c0       	rjmp	.+196    	; 0x174
		if( (step1%4==3) && (PIND&0x01) ){
  b0:	20 91 0d 01 	lds	r18, 0x010D
  b4:	82 2f       	mov	r24, r18
  b6:	83 70       	andi	r24, 0x03	; 3
  b8:	83 30       	cpi	r24, 0x03	; 3
  ba:	31 f4       	brne	.+12     	; 0xc8
  bc:	80 9b       	sbis	0x10, 0	; 16
  be:	04 c0       	rjmp	.+8      	; 0xc8
			ls1 = 1;
  c0:	81 e0       	ldi	r24, 0x01	; 1
  c2:	80 93 10 01 	sts	0x0110, r24
			PORTC = (PORTC & 0x7F)|0x80;
  c6:	af 9a       	sbi	0x15, 7	; 21
		}
		
		if(!(--timer1)){
  c8:	90 91 0a 01 	lds	r25, 0x010A
  cc:	91 50       	subi	r25, 0x01	; 1
  ce:	90 93 0a 01 	sts	0x010A, r25
  d2:	99 23       	and	r25, r25
  d4:	09 f0       	breq	.+2      	; 0xd8
  d6:	4e c0       	rjmp	.+156    	; 0x174
			reload1 = 1;
  d8:	41 e0       	ldi	r20, 0x01	; 1
			timer1 = DELAY1;	//reload timer
  da:	80 91 20 01 	lds	r24, 0x0120
  de:	80 93 0a 01 	sts	0x010A, r24
	
			if(++step1 == 48){
  e2:	82 2f       	mov	r24, r18
  e4:	84 0f       	add	r24, r20
  e6:	80 93 0d 01 	sts	0x010D, r24
  ea:	80 33       	cpi	r24, 0x30	; 48
  ec:	11 f4       	brne	.+4      	; 0xf2
				step1 = 0;
  ee:	90 93 0d 01 	sts	0x010D, r25
			}
			
			if( ((step1%4)==0) && ls1 ){
  f2:	20 91 0d 01 	lds	r18, 0x010D
  f6:	92 2f       	mov	r25, r18
  f8:	93 70       	andi	r25, 0x03	; 3
  fa:	79 f4       	brne	.+30     	; 0x11a
  fc:	80 91 10 01 	lds	r24, 0x0110
 100:	88 23       	and	r24, r24
 102:	59 f0       	breq	.+22     	; 0x11a
				ls1 = 0;
 104:	90 93 10 01 	sts	0x0110, r25
				
				if(!STEP_FUZZ1) STEP_FUZZ1 = step1;
 108:	80 91 19 01 	lds	r24, 0x0119
 10c:	88 23       	and	r24, r24
 10e:	11 f4       	brne	.+4      	; 0x114
 110:	20 93 19 01 	sts	0x0119, r18
				//PORTC = (PORTC & 0x07)|((step1<<1)&0xF8);
				PORTC&=0x7F;
 114:	af 98       	cbi	0x15, 7	; 21
				step1 = 0;
 116:	90 93 0d 01 	sts	0x010D, r25
			}
			
			PORTC = (PORTC & 0xFC)| ( (step1%4) ^ (step1%4)>>1 ); //set motor to new position
 11a:	85 b3       	in	r24, 0x15	; 21
 11c:	8c 7f       	andi	r24, 0xFC	; 252
 11e:	30 91 0d 01 	lds	r19, 0x010D
 122:	93 2f       	mov	r25, r19
 124:	93 70       	andi	r25, 0x03	; 3
 126:	29 2f       	mov	r18, r25
 128:	26 95       	lsr	r18
 12a:	92 27       	eor	r25, r18
 12c:	89 2b       	or	r24, r25
 12e:	85 bb       	out	0x15, r24	; 21
			
			if(STOP1 != 0xFF){
 130:	80 91 1b 01 	lds	r24, 0x011B
 134:	8f 3f       	cpi	r24, 0xFF	; 255
 136:	f9 f0       	breq	.+62     	; 0x176
				char tmp;
				if((char)(STOP1-step1)>=0){
 138:	98 2f       	mov	r25, r24
 13a:	93 1b       	sub	r25, r19
 13c:	0a f4       	brpl	.+2      	; 0x140
					tmp = STOP1-step1;
				}else{
					tmp = (STOP1-step1)+48;
 13e:	90 5d       	subi	r25, 0xD0	; 208
				}

				if (bmode1 == 1){
 140:	80 91 13 01 	lds	r24, 0x0113
 144:	81 30       	cpi	r24, 0x01	; 1
 146:	81 f4       	brne	.+32     	; 0x168
					DELAY1 = btable[tmp];
 148:	e9 2f       	mov	r30, r25
 14a:	ff 27       	eor	r31, r31
 14c:	e7 fd       	sbrc	r30, 7
 14e:	f0 95       	com	r31
 150:	e0 5a       	subi	r30, 0xA0	; 160
 152:	ff 4f       	sbci	r31, 0xFF	; 255
 154:	90 81       	ld	r25, Z
 156:	90 93 20 01 	sts	0x0120, r25
					if (DELAY1 == 0){
 15a:	99 23       	and	r25, r25
 15c:	61 f4       	brne	.+24     	; 0x176
						RUN1 = 0;
 15e:	90 93 1a 01 	sts	0x011A, r25
						bmode1 = 0;
 162:	90 93 13 01 	sts	0x0113, r25
 166:	07 c0       	rjmp	.+14     	; 0x176
					}
				}else if (tmp  == 0){
 168:	99 23       	and	r25, r25
 16a:	29 f4       	brne	.+10     	; 0x176
					bmode1 = 1;
 16c:	81 e0       	ldi	r24, 0x01	; 1
 16e:	80 93 13 01 	sts	0x0113, r24
 172:	01 c0       	rjmp	.+2      	; 0x176
				}
				
			}
			
		}else{
			reload1 = 0;
		}
	}else{
		reload1 = 0;
 174:	40 e0       	ldi	r20, 0x00	; 0
	}

	if( RUN2 ){
 176:	80 91 1c 01 	lds	r24, 0x011C
 17a:	88 23       	and	r24, r24
 17c:	09 f4       	brne	.+2      	; 0x180
 17e:	67 c0       	rjmp	.+206    	; 0x24e
		if( ((step2&0x03)==3) && (PIND&0x02) ){
 180:	20 91 0e 01 	lds	r18, 0x010E
 184:	82 2f       	mov	r24, r18
 186:	99 27       	eor	r25, r25
 188:	83 70       	andi	r24, 0x03	; 3
 18a:	90 70       	andi	r25, 0x00	; 0
 18c:	03 97       	sbiw	r24, 0x03	; 3
 18e:	31 f4       	brne	.+12     	; 0x19c
 190:	81 9b       	sbis	0x10, 1	; 16
 192:	04 c0       	rjmp	.+8      	; 0x19c
			ls2 = 1;
 194:	81 e0       	ldi	r24, 0x01	; 1
 196:	80 93 11 01 	sts	0x0111, r24
			PORTC = (PORTC & 0x7F)|0x80;
 19a:	af 9a       	sbi	0x15, 7	; 21
		}
		if(!(--timer2)){
 19c:	90 91 0b 01 	lds	r25, 0x010B
 1a0:	89 2f       	mov	r24, r25
 1a2:	81 50       	subi	r24, 0x01	; 1
 1a4:	80 93 0b 01 	sts	0x010B, r24
 1a8:	88 23       	and	r24, r24
 1aa:	09 f0       	breq	.+2      	; 0x1ae
 1ac:	50 c0       	rjmp	.+160    	; 0x24e
			if (reload1){timer2++;}else{
 1ae:	44 23       	and	r20, r20
 1b0:	19 f0       	breq	.+6      	; 0x1b8
 1b2:	90 93 0b 01 	sts	0x010B, r25
 1b6:	4b c0       	rjmp	.+150    	; 0x24e
			timer2 = DELAY2;	//reload timer
 1b8:	80 91 18 01 	lds	r24, 0x0118
 1bc:	80 93 0b 01 	sts	0x010B, r24
	
			if(++step2 == 48){
 1c0:	82 2f       	mov	r24, r18
 1c2:	8f 5f       	subi	r24, 0xFF	; 255
 1c4:	80 93 0e 01 	sts	0x010E, r24
 1c8:	80 33       	cpi	r24, 0x30	; 48
 1ca:	11 f4       	brne	.+4      	; 0x1d0
				step2 = 0;
 1cc:	40 93 0e 01 	sts	0x010E, r20
			}
			
			
			if( ((step2%4)==0) && ls2 ){
 1d0:	90 91 0e 01 	lds	r25, 0x010E
 1d4:	93 70       	andi	r25, 0x03	; 3
 1d6:	49 f4       	brne	.+18     	; 0x1ea
 1d8:	80 91 11 01 	lds	r24, 0x0111
 1dc:	88 23       	and	r24, r24
 1de:	29 f0       	breq	.+10     	; 0x1ea
				ls2 = 0;
 1e0:	90 93 11 01 	sts	0x0111, r25
				step2 = 0;
 1e4:	90 93 0e 01 	sts	0x010E, r25
				PORTC = (PORTC & 0x7F);
 1e8:	af 98       	cbi	0x15, 7	; 21
			}
			
			PORTC = (PORTC & 0xE7)| ( (step2%4) ^ (step2%4)>>1 )<<3; //set motor to new position
 1ea:	25 b3       	in	r18, 0x15	; 21
 1ec:	27 7e       	andi	r18, 0xE7	; 231
 1ee:	30 91 0e 01 	lds	r19, 0x010E
 1f2:	83 2f       	mov	r24, r19
 1f4:	83 70       	andi	r24, 0x03	; 3
 1f6:	98 2f       	mov	r25, r24
 1f8:	96 95       	lsr	r25
 1fa:	89 27       	eor	r24, r25
 1fc:	99 27       	eor	r25, r25
 1fe:	43 e0       	ldi	r20, 0x03	; 3
 200:	88 0f       	add	r24, r24
 202:	99 1f       	adc	r25, r25
 204:	4a 95       	dec	r20
 206:	e1 f7       	brne	.-8      	; 0x200
 208:	28 2b       	or	r18, r24
 20a:	25 bb       	out	0x15, r18	; 21
			
			if(STOP2 != 0xFF){
 20c:	80 91 1f 01 	lds	r24, 0x011F
 210:	8f 3f       	cpi	r24, 0xFF	; 255
 212:	e9 f0       	breq	.+58     	; 0x24e
				char tmp;
				if((char)(STOP2-step2)>=0){
 214:	83 1b       	sub	r24, r19
 216:	87 fd       	sbrc	r24, 7
 218:	02 c0       	rjmp	.+4      	; 0x21e
					tmp = STOP2-step2;
 21a:	e8 2f       	mov	r30, r24
 21c:	02 c0       	rjmp	.+4      	; 0x222
				}else{
					tmp = (STOP2-step2)+48;
 21e:	e8 2f       	mov	r30, r24
 220:	e0 5d       	subi	r30, 0xD0	; 208
				}
				
				if (bmode2 == 1){
 222:	80 91 14 01 	lds	r24, 0x0114
 226:	81 30       	cpi	r24, 0x01	; 1
 228:	69 f4       	brne	.+26     	; 0x244
					DELAY2 = btable[tmp];
 22a:	ff 27       	eor	r31, r31
 22c:	e7 fd       	sbrc	r30, 7
 22e:	f0 95       	com	r31
 230:	e0 5a       	subi	r30, 0xA0	; 160
 232:	ff 4f       	sbci	r31, 0xFF	; 255
 234:	80 81       	ld	r24, Z
 236:	80 93 18 01 	sts	0x0118, r24
					if (DELAY2 == 0){
 23a:	88 23       	and	r24, r24
 23c:	41 f4       	brne	.+16     	; 0x24e
						RUN2 = 0;
 23e:	80 93 1c 01 	sts	0x011C, r24
						bmode2 = 0;
 242:	03 c0       	rjmp	.+6      	; 0x24a
					}
				}else if ( tmp == 0  ){
 244:	ee 23       	and	r30, r30
 246:	19 f4       	brne	.+6      	; 0x24e
					bmode2 = 1;
 248:	81 e0       	ldi	r24, 0x01	; 1
 24a:	80 93 14 01 	sts	0x0114, r24
				}
				
			}
			}
			
		}
	}
}
 24e:	ff 91       	pop	r31
 250:	ef 91       	pop	r30
 252:	9f 91       	pop	r25
 254:	8f 91       	pop	r24
 256:	4f 91       	pop	r20
 258:	3f 91       	pop	r19
 25a:	2f 91       	pop	r18
 25c:	0f 90       	pop	r0
 25e:	0f be       	out	0x3f, r0	; 63
 260:	0f 90       	pop	r0
 262:	1f 90       	pop	r1
 264:	18 95       	reti

00000266 <timer0_on>:

void timer0_on(){
/* 	TCCR0: FOC0 WGM00 COM01 COM00 WGM01 CS02 CS01 CS00
		CS02 CS01 CS00
		 0    0    0	       stop
		 0    0    1       clk
		 0    1    0       clk/8
		 0    1    1       clk/64
		 1    0    0       clk/256
		 1    0    1       clk/1024
	
*/
	TCCR0 = 0x0A;	// CTC Mode, clk/8
 266:	8a e0       	ldi	r24, 0x0A	; 10
 268:	83 bf       	out	0x33, r24	; 51
	TCNT0 = 0;	// reset timer
 26a:	12 be       	out	0x32, r1	; 50
	OCR0 = 0xFF;	// Compare with this value
 26c:	8f ef       	ldi	r24, 0xFF	; 255
 26e:	8c bf       	out	0x3c, r24	; 60
	TIMSK = 0x02;	// Compare match Interrupt on
 270:	82 e0       	ldi	r24, 0x02	; 2
 272:	89 bf       	out	0x39, r24	; 57
}
 274:	08 95       	ret

00000276 <timer0_off>:

void timer0_off(){
	TIMSK = 0;
 276:	19 be       	out	0x39, r1	; 57
}
 278:	08 95       	ret

0000027a <init_Ports>:


void init_Ports(){
	DDRB = 0; 	//Port B all inputs
 27a:	17 ba       	out	0x17, r1	; 23
	PORTB = 0x0F;	//Pullups on on Button pins
 27c:	8f e0       	ldi	r24, 0x0F	; 15
 27e:	88 bb       	out	0x18, r24	; 24
	
	DDRC = 0xFF; 	//Port C all outputs
 280:	8f ef       	ldi	r24, 0xFF	; 255
 282:	84 bb       	out	0x14, r24	; 20
	PORTC = 0x0;	//Power off
 284:	15 ba       	out	0x15, r1	; 21
	
	DDRD = 0;	//Port D to Inputs
 286:	11 ba       	out	0x11, r1	; 17
	PORTD = 0xFF;	//Pullups on
 288:	82 bb       	out	0x12, r24	; 18
}
 28a:	08 95       	ret

0000028c <wait>:

void wait(int ms){
 28c:	9c 01       	movw	r18, r24
/* 	TCCR2: FOC2 WGM20 COM21 COM20 WGM21 CS22 CS21 CS20
		CS22 CS21 CS20
		 0    0    0	       stop
		 0    0    1       clk
		 0    1    0       clk/8
		 0    1    1       clk/32
		 1    0    0       clk/64
		 1    0    1       clk/128
		 1    1    0       clk/256
		 1    1    1       clk/1024	
*/
	TCCR2 = 0x0C;	//CTC Mode, clk/64
 28e:	8c e0       	ldi	r24, 0x0C	; 12
 290:	85 bd       	out	0x25, r24	; 37
	OCR2 = 125;	//1000Hz
 292:	8d e7       	ldi	r24, 0x7D	; 125
 294:	83 bd       	out	0x23, r24	; 35
	for(;ms>0;ms--){
 296:	12 16       	cp	r1, r18
 298:	13 06       	cpc	r1, r19
 29a:	54 f4       	brge	.+20     	; 0x2b0
		while(!(TIFR&0x80));	//wait for compare matzch flag
 29c:	08 b6       	in	r0, 0x38	; 56
 29e:	07 fe       	sbrs	r0, 7
 2a0:	fd cf       	rjmp	.-6      	; 0x29c
		TIFR=0x80;		//reset flag
 2a2:	80 e8       	ldi	r24, 0x80	; 128
 2a4:	88 bf       	out	0x38, r24	; 56
 2a6:	21 50       	subi	r18, 0x01	; 1
 2a8:	30 40       	sbci	r19, 0x00	; 0
 2aa:	12 16       	cp	r1, r18
 2ac:	13 06       	cpc	r1, r19
 2ae:	b4 f3       	brlt	.-20     	; 0x29c
	}
}
 2b0:	08 95       	ret

000002b2 <main>:



int
main (void){
 2b2:	cc e2       	ldi	r28, 0x2C	; 44
 2b4:	d8 e0       	ldi	r29, 0x08	; 8
 2b6:	de bf       	out	0x3e, r29	; 62
 2b8:	cd bf       	out	0x3d, r28	; 61
unsigned char * wheel_table1[] = {"1","1", "1,20","0,80", "0,60","0,40", "1","0,30", "0,40","0,60", "1,20","0,80", "0,60","0,40", "0,40","0,60", "1,60","0,30", "0,60","0,40", "0,40","0,60", "2,40","0,30"  };
 2ba:	80 e3       	ldi	r24, 0x30	; 48
 2bc:	6e 01       	movw	r12, r28
 2be:	08 94       	sec
 2c0:	c1 1c       	adc	r12, r1
 2c2:	d1 1c       	adc	r13, r1
 2c4:	d6 01       	movw	r26, r12
 2c6:	eb ec       	ldi	r30, 0xCB	; 203
 2c8:	f0 e0       	ldi	r31, 0x00	; 0
 2ca:	01 90       	ld	r0, Z+
 2cc:	0d 92       	st	X+, r0
 2ce:	8a 95       	dec	r24
 2d0:	e1 f7       	brne	.-8      	; 0x2ca

	init_Ports();
 2d2:	0e 94 3d 01 	call	0x27a

	display_init();
 2d6:	0e 94 55 02 	call	0x4aa
	
	display_print("Hello   World!");
 2da:	8b ef       	ldi	r24, 0xFB	; 251
 2dc:	90 e0       	ldi	r25, 0x00	; 0
 2de:	0e 94 b6 02 	call	0x56c
	
	timer0_on();
 2e2:	0e 94 33 01 	call	0x266
	sei();
 2e6:	78 94       	sei

	fax_init();
 2e8:	0e 94 3d 03 	call	0x67a
	
	
	for(;;){
	
		unsigned char delay;
	
		char x = 0;
 2ec:	ee 24       	eor	r14, r14
		for(x=0; x<48; x+=4){
		
		char y;
		for(y=0;y<11;y++){
 2ee:	00 e0       	ldi	r16, 0x00	; 0
	
			fax_led_on(y);
 2f0:	80 2f       	mov	r24, r16
 2f2:	0e 94 13 03 	call	0x626
			wait(50);
 2f6:	82 e3       	ldi	r24, 0x32	; 50
 2f8:	90 e0       	ldi	r25, 0x00	; 0
 2fa:	0e 94 46 01 	call	0x28c
 2fe:	0f 5f       	subi	r16, 0xFF	; 255
 300:	0b 30       	cpi	r16, 0x0B	; 11
 302:	b4 f3       	brlt	.-20     	; 0x2f0
		}
	
		for(y=0;y<11;y++){
 304:	00 e0       	ldi	r16, 0x00	; 0
			fax_led_off(y);
 306:	80 2f       	mov	r24, r16
 308:	0e 94 27 03 	call	0x64e
			wait(50);
 30c:	82 e3       	ldi	r24, 0x32	; 50
 30e:	90 e0       	ldi	r25, 0x00	; 0
 310:	0e 94 46 01 	call	0x28c
 314:	0f 5f       	subi	r16, 0xFF	; 255
 316:	0b 30       	cpi	r16, 0x0B	; 11
 318:	b4 f3       	brlt	.-20     	; 0x306
		}
			
		
		PORTC = PORTC|0x04;
 31a:	aa 9a       	sbi	0x15, 2	; 21
		STOP1 = 0xFF;	//Stop off;
 31c:	8f ef       	ldi	r24, 0xFF	; 255
 31e:	80 93 1b 01 	sts	0x011B, r24
		RUN1 = 1;
 322:	81 e0       	ldi	r24, 0x01	; 1
 324:	80 93 1a 01 	sts	0x011A, r24
		for(delay = 0x40; delay >= 0x0E; delay--){
 328:	f0 e4       	ldi	r31, 0x40	; 64
 32a:	ff 2e       	mov	r15, r31
 32c:	00 e2       	ldi	r16, 0x20	; 32
 32e:	10 e0       	ldi	r17, 0x00	; 0
			DELAY1 = delay;
 330:	f0 92 20 01 	sts	0x0120, r15
			wait ( (0x60-delay)>>2 );
 334:	c8 01       	movw	r24, r16
 336:	95 95       	asr	r25
 338:	87 95       	ror	r24
 33a:	95 95       	asr	r25
 33c:	87 95       	ror	r24
 33e:	0e 94 46 01 	call	0x28c
 342:	fa 94       	dec	r15
 344:	0f 5f       	subi	r16, 0xFF	; 255
 346:	1f 4f       	sbci	r17, 0xFF	; 255
 348:	8d e0       	ldi	r24, 0x0D	; 13
 34a:	8f 15       	cp	r24, r15
 34c:	88 f3       	brcs	.-30     	; 0x330
	
		}
		
		wait(100);
 34e:	84 e6       	ldi	r24, 0x64	; 100
 350:	90 e0       	ldi	r25, 0x00	; 0
 352:	0e 94 46 01 	call	0x28c
		
		
		PORTC = PORTC|0x20;
 356:	ad 9a       	sbi	0x15, 5	; 21
		STOP2 = 0xFF;
 358:	8f ef       	ldi	r24, 0xFF	; 255
 35a:	80 93 1f 01 	sts	0x011F, r24
		RUN2 = 1;
 35e:	81 e0       	ldi	r24, 0x01	; 1
 360:	80 93 1c 01 	sts	0x011C, r24
		for(delay = 0x40; delay >= 0x0E; delay--){
 364:	70 e4       	ldi	r23, 0x40	; 64
 366:	f7 2e       	mov	r15, r23
 368:	00 e2       	ldi	r16, 0x20	; 32
 36a:	10 e0       	ldi	r17, 0x00	; 0
			DELAY2 = delay;
 36c:	f0 92 18 01 	sts	0x0118, r15
			wait ( (0x60-delay)>>2 );
 370:	c8 01       	movw	r24, r16
 372:	95 95       	asr	r25
 374:	87 95       	ror	r24
 376:	95 95       	asr	r25
 378:	87 95       	ror	r24
 37a:	0e 94 46 01 	call	0x28c
 37e:	fa 94       	dec	r15
 380:	0f 5f       	subi	r16, 0xFF	; 255
 382:	1f 4f       	sbci	r17, 0xFF	; 255
 384:	ed e0       	ldi	r30, 0x0D	; 13
 386:	ef 15       	cp	r30, r15
 388:	88 f3       	brcs	.-30     	; 0x36c
		}
		
		display_clear_line(0);
 38a:	80 e0       	ldi	r24, 0x00	; 0
 38c:	0e 94 a2 02 	call	0x544
		display_print(wheel_table1[(x>>2)<<1]);
 390:	8e 2d       	mov	r24, r14
 392:	85 95       	asr	r24
 394:	85 95       	asr	r24
 396:	08 2f       	mov	r16, r24
 398:	11 27       	eor	r17, r17
 39a:	07 fd       	sbrc	r16, 7
 39c:	10 95       	com	r17
 39e:	00 0f       	add	r16, r16
 3a0:	11 1f       	adc	r17, r17
 3a2:	00 0f       	add	r16, r16
 3a4:	11 1f       	adc	r17, r17
 3a6:	0c 0d       	add	r16, r12
 3a8:	1d 1d       	adc	r17, r13
 3aa:	f8 01       	movw	r30, r16
 3ac:	80 81       	ld	r24, Z
 3ae:	91 81       	ldd	r25, Z+1	; 0x01
 3b0:	0e 94 b6 02 	call	0x56c
		
		display_clear_line(1);
 3b4:	81 e0       	ldi	r24, 0x01	; 1
 3b6:	0e 94 a2 02 	call	0x544
		display_print(wheel_table1[((x>>2)<<1)+1]);
 3ba:	f8 01       	movw	r30, r16
 3bc:	82 81       	ldd	r24, Z+2	; 0x02
 3be:	93 81       	ldd	r25, Z+3	; 0x03
 3c0:	0e 94 b6 02 	call	0x56c
		
		
		wait(1500);
 3c4:	8c ed       	ldi	r24, 0xDC	; 220
 3c6:	95 e0       	ldi	r25, 0x05	; 5
 3c8:	0e 94 46 01 	call	0x28c
		
		char muh[3];
		itoa(STEP_FUZZ1, muh, 10);
 3cc:	80 91 19 01 	lds	r24, 0x0119
 3d0:	99 27       	eor	r25, r25
 3d2:	4a e0       	ldi	r20, 0x0A	; 10
 3d4:	50 e0       	ldi	r21, 0x00	; 0
 3d6:	be 01       	movw	r22, r28
 3d8:	6f 5c       	subi	r22, 0xCF	; 207
 3da:	7f 4f       	sbci	r23, 0xFF	; 255
 3dc:	0e 94 47 03 	call	0x68e
		//display_set_cursor(0,6);
		//display_print(muh);
		STEP_FUZZ1 = 0;
 3e0:	10 92 19 01 	sts	0x0119, r1
		
		
		STOP1 = x;
 3e4:	e0 92 1b 01 	sts	0x011B, r14
		wait (500);
 3e8:	84 ef       	ldi	r24, 0xF4	; 244
 3ea:	91 e0       	ldi	r25, 0x01	; 1
 3ec:	0e 94 46 01 	call	0x28c
		PORTC = (PORTC & ~0x04);
 3f0:	aa 98       	cbi	0x15, 2	; 21
	
		wait(800);
 3f2:	80 e2       	ldi	r24, 0x20	; 32
 3f4:	93 e0       	ldi	r25, 0x03	; 3
 3f6:	0e 94 46 01 	call	0x28c
		
		STOP2 = x;
 3fa:	e0 92 1f 01 	sts	0x011F, r14
		wait (500);
 3fe:	84 ef       	ldi	r24, 0xF4	; 244
 400:	91 e0       	ldi	r25, 0x01	; 1
 402:	0e 94 46 01 	call	0x28c
		PORTC = (PORTC & ~0x20);
 406:	ad 98       	cbi	0x15, 5	; 21
	
		
		
		wait (1000);
 408:	88 ee       	ldi	r24, 0xE8	; 232
 40a:	93 e0       	ldi	r25, 0x03	; 3
 40c:	0e 94 46 01 	call	0x28c
 410:	f4 e0       	ldi	r31, 0x04	; 4
 412:	ef 0e       	add	r14, r31
 414:	8f e2       	ldi	r24, 0x2F	; 47
 416:	8e 15       	cp	r24, r14
 418:	0c f0       	brlt	.+2      	; 0x41c
 41a:	69 cf       	rjmp	.-302    	; 0x2ee
 41c:	67 cf       	rjmp	.-306    	; 0x2ec

0000041e <wait50ms>:


void wait50ms(){
	uint16_t x; char y;
	for (y=1;y<8;y++){
 41e:	26 e0       	ldi	r18, 0x06	; 6
		for (x=1;x<50000;x++){};
 420:	84 e0       	ldi	r24, 0x04	; 4
 422:	90 e0       	ldi	r25, 0x00	; 0
 424:	04 96       	adiw	r24, 0x04	; 4
 426:	33 ec       	ldi	r19, 0xC3	; 195
 428:	80 35       	cpi	r24, 0x50	; 80
 42a:	93 07       	cpc	r25, r19
 42c:	d8 f3       	brcs	.-10     	; 0x424
 42e:	21 50       	subi	r18, 0x01	; 1
 430:	27 ff       	sbrs	r18, 7
 432:	f6 cf       	rjmp	.-20     	; 0x420
	}
}
 434:	08 95       	ret

00000436 <wait200us>:
void wait200us(){
	uint8_t x;
	for (x=1;x<200;x++){};
 436:	84 e0       	ldi	r24, 0x04	; 4
 438:	8c 5f       	subi	r24, 0xFC	; 252
 43a:	88 3c       	cpi	r24, 0xC8	; 200
 43c:	e8 f3       	brcs	.-6      	; 0x438
}
 43e:	08 95       	ret

00000440 <hd44780_send>:

void hd44780_send(uint8_t data){
	uint8_t busy;
	
#ifdef IF4BIT	
	DISP_PORT_C |= _BV(PIN_E);
	DISP_PORT_D &= 0xF0;
	DISP_PORT_D |= ((data >> 4) & 0x0F);
	DISP_PORT_C &= ~_BV(PIN_E);
	DISP_PORT_C |= _BV(PIN_E);
	DISP_PORT_D &= 0xF0;
	DISP_PORT_D |= (data & 0x0F);
	DISP_PORT_C &= ~_BV(PIN_E);
#else
	DISP_PORT_C |= _BV(PIN_E);
 440:	96 9a       	sbi	0x12, 6	; 18
	DISP_PORT_D = (data);
 442:	8b bb       	out	0x1b, r24	; 27
	DISP_PORT_C &= ~_BV(PIN_E);
 444:	96 98       	cbi	0x12, 6	; 18
#endif

#ifdef IF4BIT
	DISP_DDR_D &= 0XF0;		//Data lines 3:0 to Input
	DISP_PORT_D |= 0x0F;		//Pullups on on Data lines
#else
	DISP_DDR_D = 0x00;		//Data lines to Input
 446:	1a ba       	out	0x1a, r1	; 26
	DISP_PORT_D = 0xFF;		//Pullups on
 448:	8f ef       	ldi	r24, 0xFF	; 255
 44a:	8b bb       	out	0x1b, r24	; 27
#endif

	DISP_PORT_C = (DISP_PORT_C | 1<<PIN_RW) & ~(1<<PIN_RS);
 44c:	82 b3       	in	r24, 0x12	; 18
 44e:	80 62       	ori	r24, 0x20	; 32
 450:	8f 77       	andi	r24, 0x7F	; 127
 452:	82 bb       	out	0x12, r24	; 18

	do{
		DISP_PORT_C |= _BV(PIN_E);
 454:	96 9a       	sbi	0x12, 6	; 18
		asm volatile ("nop\n\tnop\n\t"::);
 456:	00 00       	nop
 458:	00 00       	nop
#ifdef IF4BIT		
		busy = (DISP_PIN & 0x08);
		DISP_PORT_C &= ~_BV(PIN_E);
		DISP_PORT_C |= _BV(PIN_E);
		DISP_PORT_C &= ~_BV(PIN_E);
#else
		busy = (DISP_PIN & 0x80);
 45a:	89 b3       	in	r24, 0x19	; 25
 45c:	80 78       	andi	r24, 0x80	; 128
		DISP_PORT_C &= ~_BV(PIN_E);
 45e:	96 98       	cbi	0x12, 6	; 18
#endif	
	}while(busy);
 460:	c9 f7       	brne	.-14     	; 0x454

	DISP_PORT_C &= ~(1<<PIN_RW | 1<<PIN_RS );
 462:	82 b3       	in	r24, 0x12	; 18
 464:	8f 75       	andi	r24, 0x5F	; 95
 466:	82 bb       	out	0x12, r24	; 18
#ifdef IF4BIT	
	DISP_DDR_D |= 0x0F;		//Data Lines to Output
#else
	DISP_DDR_D = 0xFF;
 468:	8f ef       	ldi	r24, 0xFF	; 255
 46a:	8a bb       	out	0x1a, r24	; 26
#endif
}
 46c:	08 95       	ret

0000046e <hd44780_send_nobusy>:

// send Data to display without checking the Busy Flag, needed for iniializing Display
void hd44780_send_nobusy(uint8_t data){
#ifdef IF4BIT	
	DISP_PORT_C |= _BV(PIN_E);
	DISP_PORT_D &= 0xF0;
	DISP_PORT_D |= (data >> 4);
	DISP_PORT_C &= ~_BV(PIN_E);
	wait200us();
	DISP_PORT_C |= _BV(PIN_E);
	DISP_PORT_D &= 0xF0;
	DISP_PORT_D |= (data & 0x0F);
	DISP_PORT_C &= ~_BV(PIN_E);
	wait200us();
#else
	DISP_PORT_C |= _BV(PIN_E);
 46e:	96 9a       	sbi	0x12, 6	; 18
	DISP_PORT_D = data;
 470:	8b bb       	out	0x1b, r24	; 27
	DISP_PORT_C &= ~_BV(PIN_E);
 472:	96 98       	cbi	0x12, 6	; 18
	wait200us();
 474:	0e 94 1b 02 	call	0x436
#endif
}
 478:	08 95       	ret

0000047a <hd44780_read>:

/* reads and returns the address counter */
uint8_t hd44780_read(){
	uint8_t address;
#ifdef IF4BIT
	DISP_DDR_D &= 0xF0;
	DISP_PORT_D |= 0x0F;
	
	DISP_PORT_C &= ~(1<<PIN_RS);
	DISP_PORT_C |= (1<<PIN_RW);
	
	DISP_PORT_C |= 1<<PIN_E;
	asm volatile ("nop\n\tnop\n\t"::);
	address = DISP_PIN & 0x07; //dont read busy flag
	DISP_PORT_C &= ~_BV(PIN_E);
	address <<= 4;
	DISP_PORT_C |= _BV(PIN_E);
	asm volatile ("nop\n\tnop\n\t"::);
	address |= DISP_PIN & 0x0F;
	DISP_PORT_C &= ~_BV(PIN_E);

	DISP_PORT_C &= ~(1<<PIN_RW);	
	DISP_DDR_D |= 0x0F;
#else	
	DISP_DDR_D = 0x00;
 47a:	1a ba       	out	0x1a, r1	; 26
	DISP_PORT_D = 0xFF;
 47c:	8f ef       	ldi	r24, 0xFF	; 255
 47e:	8b bb       	out	0x1b, r24	; 27
	
	DISP_PORT_C &= ~(1<<PIN_RS);
 480:	97 98       	cbi	0x12, 7	; 18
	DISP_PORT_C |= (1<<PIN_RW);
 482:	95 9a       	sbi	0x12, 5	; 18
	
	DISP_PORT_C |= 1<<PIN_E;
 484:	96 9a       	sbi	0x12, 6	; 18
	asm volatile ("nop\n\tnop\n\t"::);
 486:	00 00       	nop
 488:	00 00       	nop
	address = DISP_PIN & 0x7F; //dont read busy flag
 48a:	99 b3       	in	r25, 0x19	; 25
 48c:	9f 77       	andi	r25, 0x7F	; 127
	DISP_PORT_C &= ~_BV(PIN_E);
 48e:	96 98       	cbi	0x12, 6	; 18
	
	DISP_PORT_C &= ~(1<<PIN_RW);
 490:	95 98       	cbi	0x12, 5	; 18
	DISP_DDR_D = 0xFF;
 492:	8a bb       	out	0x1a, r24	; 26
#endif
	return address;
 494:	89 2f       	mov	r24, r25
 496:	99 27       	eor	r25, r25
}
 498:	08 95       	ret

0000049a <hd44780_command>:

void hd44780_command(uint8_t command){
	DISP_PORT_C &= ~(1<<PIN_RS);
 49a:	97 98       	cbi	0x12, 7	; 18
	hd44780_send(command);
 49c:	0e 94 20 02 	call	0x440
}
 4a0:	08 95       	ret

000004a2 <hd44780_data>:

void hd44780_data(uint8_t data){
	DISP_PORT_C |= 1<<PIN_RS;
 4a2:	97 9a       	sbi	0x12, 7	; 18
	hd44780_send(data);
 4a4:	0e 94 20 02 	call	0x440
}
 4a8:	08 95       	ret

000004aa <hd44780_init>:

/* init the controller and clear the Display */
void hd44780_init(){

#ifdef IF4BIT	
	DISP_DDR_D |= 0x0F;
	DISP_PORT_D &= 0xF0;
#else
	DISP_DDR_D = 0xFF;
 4aa:	8f ef       	ldi	r24, 0xFF	; 255
 4ac:	8a bb       	out	0x1a, r24	; 26
	DISP_PORT_D = 0x00;
 4ae:	1b ba       	out	0x1b, r1	; 27
#endif
	DISP_DDR_C |= (1<<PIN_E|1<<PIN_RW|1<<PIN_RS);
 4b0:	81 b3       	in	r24, 0x11	; 17
 4b2:	80 6e       	ori	r24, 0xE0	; 224
 4b4:	81 bb       	out	0x11, r24	; 17
	DISP_PORT_C &= ~(1<<PIN_E|1<<PIN_RW|1<<PIN_RS);
 4b6:	82 b3       	in	r24, 0x12	; 18
 4b8:	8f 71       	andi	r24, 0x1F	; 31
 4ba:	82 bb       	out	0x12, r24	; 18
	
	wait50ms();
 4bc:	0e 94 0f 02 	call	0x41e
#ifdef IF4BIT
	hd44780_send_nobusy(0x33);
	hd44780_send_nobusy(0x32);// Put Display in 4bit mode
	hd44780_send_nobusy(0x28);// Put Display in 4bit mode
	hd44780_command(0x28);// 2 Lines 5x7 DOT
	
#else
	hd44780_send_nobusy(0x30);
 4c0:	80 e3       	ldi	r24, 0x30	; 48
 4c2:	0e 94 37 02 	call	0x46e
	hd44780_send_nobusy(0x30);
 4c6:	80 e3       	ldi	r24, 0x30	; 48
 4c8:	0e 94 37 02 	call	0x46e
	hd44780_send_nobusy(0x30);
 4cc:	80 e3       	ldi	r24, 0x30	; 48
 4ce:	0e 94 37 02 	call	0x46e
	hd44780_send_nobusy(0x30);// Put Display in 8bit mode
 4d2:	80 e3       	ldi	r24, 0x30	; 48
 4d4:	0e 94 37 02 	call	0x46e
	hd44780_command(0x30);
 4d8:	80 e3       	ldi	r24, 0x30	; 48
 4da:	0e 94 4d 02 	call	0x49a
	hd44780_command(0x38);// 2 Lines 5x7 DOT
 4de:	88 e3       	ldi	r24, 0x38	; 56
 4e0:	0e 94 4d 02 	call	0x49a
#endif

	hd44780_command(0x10);// cursor move
 4e4:	80 e1       	ldi	r24, 0x10	; 16
 4e6:	0e 94 4d 02 	call	0x49a
	hd44780_command(0x0F);//Display on, cursor on, cursor blink
 4ea:	8f e0       	ldi	r24, 0x0F	; 15
 4ec:	0e 94 4d 02 	call	0x49a

	hd44780_command(0x01);//clear Display
 4f0:	81 e0       	ldi	r24, 0x01	; 1
 4f2:	0e 94 4d 02 	call	0x49a
}
 4f6:	08 95       	ret

000004f8 <hd44780_set_cursor>:

void hd44780_set_cursor(uint8_t row, uint8_t col){
	hd44780_command(0x80|(uint8_t)(row<<6)|col);
 4f8:	82 95       	swap	r24
 4fa:	88 0f       	add	r24, r24
 4fc:	88 0f       	add	r24, r24
 4fe:	80 7c       	andi	r24, 0xC0	; 192
 500:	86 2b       	or	r24, r22
 502:	80 68       	ori	r24, 0x80	; 128
 504:	0e 94 4d 02 	call	0x49a
}
 508:	08 95       	ret

0000050a <hd44780_backspace>:

void hd44780_backspace(uint8_t num){
 50a:	0f 93       	push	r16
 50c:	1f 93       	push	r17
 50e:	cf 93       	push	r28
 510:	08 2f       	mov	r16, r24
	uint8_t curs_pos = hd44780_read();
 512:	0e 94 3d 02 	call	0x47a
 516:	c8 2f       	mov	r28, r24
	uint8_t x;
	hd44780_command(SET_DDRAM|(curs_pos-num));
 518:	80 1b       	sub	r24, r16
 51a:	80 68       	ori	r24, 0x80	; 128
 51c:	0e 94 4d 02 	call	0x49a
	for(x=0;x<num;x++){
 520:	10 e0       	ldi	r17, 0x00	; 0
 522:	10 17       	cp	r17, r16
 524:	30 f4       	brcc	.+12     	; 0x532
		hd44780_data(' ');
 526:	80 e2       	ldi	r24, 0x20	; 32
 528:	0e 94 51 02 	call	0x4a2
 52c:	1f 5f       	subi	r17, 0xFF	; 255
 52e:	10 17       	cp	r17, r16
 530:	d0 f3       	brcs	.-12     	; 0x526
	}
	hd44780_command(SET_DDRAM|(curs_pos-1));
 532:	c1 50       	subi	r28, 0x01	; 1
 534:	c0 68       	ori	r28, 0x80	; 128
 536:	8c 2f       	mov	r24, r28
 538:	0e 94 4d 02 	call	0x49a
}
 53c:	cf 91       	pop	r28
 53e:	1f 91       	pop	r17
 540:	0f 91       	pop	r16
 542:	08 95       	ret

00000544 <hd44780_clear_line>:

void hd44780_clear_line(uint8_t line){
 544:	1f 93       	push	r17
 546:	cf 93       	push	r28
 548:	18 2f       	mov	r17, r24
	uint8_t x;
	hd44780_set_cursor(line,0);
 54a:	60 e0       	ldi	r22, 0x00	; 0
 54c:	0e 94 7c 02 	call	0x4f8
	for(x=0;x<DISP_LEN;x++){
 550:	c0 e0       	ldi	r28, 0x00	; 0
		hd44780_data(' ');
 552:	80 e2       	ldi	r24, 0x20	; 32
 554:	0e 94 51 02 	call	0x4a2
 558:	cf 5f       	subi	r28, 0xFF	; 255
 55a:	c0 31       	cpi	r28, 0x10	; 16
 55c:	d0 f3       	brcs	.-12     	; 0x552
	}
	hd44780_set_cursor(line,0);
 55e:	60 e0       	ldi	r22, 0x00	; 0
 560:	81 2f       	mov	r24, r17
 562:	0e 94 7c 02 	call	0x4f8
}
 566:	cf 91       	pop	r28
 568:	1f 91       	pop	r17
 56a:	08 95       	ret

0000056c <hd44780_print>:

void hd44780_print(char * string){
 56c:	cf 93       	push	r28
 56e:	df 93       	push	r29
 570:	ec 01       	movw	r28, r24
	char c;
	while ((c = *string++)){
 572:	89 91       	ld	r24, Y+
 574:	88 23       	and	r24, r24
 576:	29 f0       	breq	.+10     	; 0x582
		hd44780_data(c);
 578:	0e 94 51 02 	call	0x4a2
 57c:	89 91       	ld	r24, Y+
 57e:	88 23       	and	r24, r24
 580:	d9 f7       	brne	.-10     	; 0x578
	}
}
 582:	df 91       	pop	r29
 584:	cf 91       	pop	r28
 586:	08 95       	ret

00000588 <hd44780_print_P>:

void hd44780_print_P(PGM_P string){
 588:	cf 93       	push	r28
 58a:	df 93       	push	r29
 58c:	ec 01       	movw	r28, r24
	char c;
	while ((c = pgm_read_byte(string++))){
 58e:	fc 01       	movw	r30, r24
 590:	21 96       	adiw	r28, 0x01	; 1
 592:	84 91       	lpm	r24, Z
 594:	88 23       	and	r24, r24
 596:	39 f0       	breq	.+14     	; 0x5a6
		hd44780_data(c);
 598:	0e 94 51 02 	call	0x4a2
 59c:	fe 01       	movw	r30, r28
 59e:	21 96       	adiw	r28, 0x01	; 1
 5a0:	84 91       	lpm	r24, Z
 5a2:	88 23       	and	r24, r24
 5a4:	c9 f7       	brne	.-14     	; 0x598
	}
} 
 5a6:	df 91       	pop	r29
 5a8:	cf 91       	pop	r28
 5aa:	08 95       	ret

000005ac <hd44780_load_font_P>:

void hd44780_load_font_P(uint8_t charnum, PGM_P data){
 5ac:	0f 93       	push	r16
 5ae:	1f 93       	push	r17
 5b0:	cf 93       	push	r28
 5b2:	df 93       	push	r29
 5b4:	18 2f       	mov	r17, r24
 5b6:	eb 01       	movw	r28, r22
	uint8_t x, address;
	address = hd44780_read();
 5b8:	0e 94 3d 02 	call	0x47a
 5bc:	08 2f       	mov	r16, r24
	hd44780_command((uint8_t)(charnum<<3)|0x40); //set cgram address
 5be:	11 0f       	add	r17, r17
 5c0:	11 0f       	add	r17, r17
 5c2:	11 0f       	add	r17, r17
 5c4:	10 64       	ori	r17, 0x40	; 64
 5c6:	81 2f       	mov	r24, r17
 5c8:	0e 94 4d 02 	call	0x49a
	for (x=0;x<8;x++){
 5cc:	10 e0       	ldi	r17, 0x00	; 0
		hd44780_data(pgm_read_byte(data++));	
 5ce:	fe 01       	movw	r30, r28
 5d0:	21 96       	adiw	r28, 0x01	; 1
 5d2:	84 91       	lpm	r24, Z
 5d4:	0e 94 51 02 	call	0x4a2
 5d8:	1f 5f       	subi	r17, 0xFF	; 255
 5da:	18 30       	cpi	r17, 0x08	; 8
 5dc:	c0 f3       	brcs	.-16     	; 0x5ce
	}
	/*restore position where cursor was */
	hd44780_command(0x80|address);
 5de:	00 68       	ori	r16, 0x80	; 128
 5e0:	80 2f       	mov	r24, r16
 5e2:	0e 94 4d 02 	call	0x49a
}
 5e6:	df 91       	pop	r29
 5e8:	cf 91       	pop	r28
 5ea:	1f 91       	pop	r17
 5ec:	0f 91       	pop	r16
 5ee:	08 95       	ret

000005f0 <set_leds>:

static unsigned int LEDS;

static void set_leds(){
	FAXPORT_D = ~(unsigned char)LEDS;
 5f0:	80 91 16 01 	lds	r24, 0x0116
 5f4:	80 95       	com	r24
 5f6:	8b bb       	out	0x1b, r24	; 27
	FAXPORT_C |= 1<<CLK_U1_PIN;
 5f8:	94 9a       	sbi	0x12, 4	; 18
	FAXPORT_C &= ~(1<<CLK_U1_PIN);
 5fa:	94 98       	cbi	0x12, 4	; 18
	
	FAXPORT_D = ~(unsigned char)(LEDS>>4);
 5fc:	80 91 16 01 	lds	r24, 0x0116
 600:	90 91 17 01 	lds	r25, 0x0117
 604:	24 e0       	ldi	r18, 0x04	; 4
 606:	96 95       	lsr	r25
 608:	87 95       	ror	r24
 60a:	2a 95       	dec	r18
 60c:	e1 f7       	brne	.-8      	; 0x606
 60e:	80 95       	com	r24
 610:	8b bb       	out	0x1b, r24	; 27
	FAXPORT_C |= 1<<CLK_U2_PIN;
 612:	93 9a       	sbi	0x12, 3	; 18
	FAXPORT_C &= ~(1<<CLK_U2_PIN);
 614:	93 98       	cbi	0x12, 3	; 18
}
 616:	08 95       	ret

00000618 <fax_led_set_pattern>:

void fax_led_set_pattern(unsigned int pattern){
	LEDS = pattern;
 618:	90 93 17 01 	sts	0x0117, r25
 61c:	80 93 16 01 	sts	0x0116, r24
	set_leds();
 620:	0e 94 f8 02 	call	0x5f0
}
 624:	08 95       	ret

00000626 <fax_led_on>:

void fax_led_on(unsigned char num){
	LEDS |= 1<<num;
 626:	21 e0       	ldi	r18, 0x01	; 1
 628:	30 e0       	ldi	r19, 0x00	; 0
 62a:	02 c0       	rjmp	.+4      	; 0x630
 62c:	22 0f       	add	r18, r18
 62e:	33 1f       	adc	r19, r19
 630:	8a 95       	dec	r24
 632:	e2 f7       	brpl	.-8      	; 0x62c
 634:	80 91 16 01 	lds	r24, 0x0116
 638:	90 91 17 01 	lds	r25, 0x0117
 63c:	82 2b       	or	r24, r18
 63e:	93 2b       	or	r25, r19
 640:	90 93 17 01 	sts	0x0117, r25
 644:	80 93 16 01 	sts	0x0116, r24
	set_leds();
 648:	0e 94 f8 02 	call	0x5f0
}
 64c:	08 95       	ret

0000064e <fax_led_off>:

void fax_led_off(unsigned char num){
	LEDS &= ~(1<<num);
 64e:	21 e0       	ldi	r18, 0x01	; 1
 650:	30 e0       	ldi	r19, 0x00	; 0
 652:	02 c0       	rjmp	.+4      	; 0x658
 654:	22 0f       	add	r18, r18
 656:	33 1f       	adc	r19, r19
 658:	8a 95       	dec	r24
 65a:	e2 f7       	brpl	.-8      	; 0x654
 65c:	20 95       	com	r18
 65e:	30 95       	com	r19
 660:	80 91 16 01 	lds	r24, 0x0116
 664:	90 91 17 01 	lds	r25, 0x0117
 668:	82 23       	and	r24, r18
 66a:	93 23       	and	r25, r19
 66c:	90 93 17 01 	sts	0x0117, r25
 670:	80 93 16 01 	sts	0x0116, r24
	set_leds();
 674:	0e 94 f8 02 	call	0x5f0
}
 678:	08 95       	ret

0000067a <fax_init>:

void fax_init(){
	FAXPORT_C |= 1<<NOE_U3_PIN ;
 67a:	92 9a       	sbi	0x12, 2	; 18
	FAXPORT_C &= ~((1<<CLK_U1_PIN)|(1<<CLK_U2_PIN));
 67c:	82 b3       	in	r24, 0x12	; 18
 67e:	87 7e       	andi	r24, 0xE7	; 231
 680:	82 bb       	out	0x12, r24	; 18

	FAXPORT_C_DDR |= (1<<CLK_U1_PIN)|(1<<CLK_U2_PIN)|(1<<NOE_U3_PIN);
 682:	81 b3       	in	r24, 0x11	; 17
 684:	8c 61       	ori	r24, 0x1C	; 28
 686:	81 bb       	out	0x11, r24	; 17

	set_leds();
 688:	0e 94 f8 02 	call	0x5f0
}
 68c:	08 95       	ret

0000068e <itoa>:
 68e:	e6 2f       	mov	r30, r22
 690:	f7 2f       	mov	r31, r23
 692:	2e 2f       	mov	r18, r30
 694:	3f 2f       	mov	r19, r31
 696:	e8 94       	clt
 698:	42 30       	cpi	r20, 0x02	; 2
 69a:	cc f0       	brlt	.+50     	; 0x6ce
 69c:	45 32       	cpi	r20, 0x25	; 37
 69e:	bc f4       	brge	.+46     	; 0x6ce
 6a0:	4a 30       	cpi	r20, 0x0A	; 10
 6a2:	29 f4       	brne	.+10     	; 0x6ae
 6a4:	97 fb       	bst	r25, 7
 6a6:	1e f4       	brtc	.+6      	; 0x6ae
 6a8:	90 95       	com	r25
 6aa:	81 95       	neg	r24
 6ac:	9f 4f       	sbci	r25, 0xFF	; 255

000006ae <divide_loop>:
 6ae:	64 2f       	mov	r22, r20
 6b0:	77 27       	eor	r23, r23
 6b2:	0e 94 7c 03 	call	0x6f8
 6b6:	80 5d       	subi	r24, 0xD0	; 208
 6b8:	8a 33       	cpi	r24, 0x3A	; 58
 6ba:	0c f0       	brlt	.+2      	; 0x6be
 6bc:	89 5d       	subi	r24, 0xD9	; 217

000006be <L_10>:
 6be:	81 93       	st	Z+, r24
 6c0:	86 2f       	mov	r24, r22
 6c2:	97 2f       	mov	r25, r23
 6c4:	00 97       	sbiw	r24, 0x00	; 0
 6c6:	99 f7       	brne	.-26     	; 0x6ae
 6c8:	16 f4       	brtc	.+4      	; 0x6ce
 6ca:	5d e2       	ldi	r21, 0x2D	; 45
 6cc:	51 93       	st	Z+, r21

000006ce <terminate>:
 6ce:	93 2f       	mov	r25, r19
 6d0:	82 2f       	mov	r24, r18
 6d2:	10 82       	st	Z, r1
 6d4:	0c 94 6c 03 	jmp	0x6d8

000006d8 <strrev>:
 6d8:	dc 01       	movw	r26, r24
 6da:	fc 01       	movw	r30, r24

000006dc <.strrev_eos>:
 6dc:	01 90       	ld	r0, Z+
 6de:	00 20       	and	r0, r0
 6e0:	e9 f7       	brne	.-6      	; 0x6dc
 6e2:	32 97       	sbiw	r30, 0x02	; 2

000006e4 <.strrev_loop>:
 6e4:	ae 17       	cp	r26, r30
 6e6:	bf 07       	cpc	r27, r31
 6e8:	30 f4       	brcc	.+12     	; 0x6f6
 6ea:	7c 91       	ld	r23, X
 6ec:	60 81       	ld	r22, Z
 6ee:	70 83       	st	Z, r23
 6f0:	31 97       	sbiw	r30, 0x01	; 1
 6f2:	6d 93       	st	X+, r22
 6f4:	f7 cf       	rjmp	.-18     	; 0x6e4

000006f6 <.strrev_done>:
 6f6:	08 95       	ret

000006f8 <__udivmodhi4>:
 6f8:	aa 1b       	sub	r26, r26
 6fa:	bb 1b       	sub	r27, r27
 6fc:	51 e1       	ldi	r21, 0x11	; 17
 6fe:	07 c0       	rjmp	.+14     	; 0x70e

00000700 <__udivmodhi4_loop>:
 700:	aa 1f       	adc	r26, r26
 702:	bb 1f       	adc	r27, r27
 704:	a6 17       	cp	r26, r22
 706:	b7 07       	cpc	r27, r23
 708:	10 f0       	brcs	.+4      	; 0x70e
 70a:	a6 1b       	sub	r26, r22
 70c:	b7 0b       	sbc	r27, r23

0000070e <__udivmodhi4_ep>:
 70e:	88 1f       	adc	r24, r24
 710:	99 1f       	adc	r25, r25
 712:	5a 95       	dec	r21
 714:	a9 f7       	brne	.-22     	; 0x700
 716:	80 95       	com	r24
 718:	90 95       	com	r25
 71a:	bc 01       	movw	r22, r24
 71c:	cd 01       	movw	r24, r26
 71e:	08 95       	ret
